# -*- coding: utf-8 -*-
"""Math Modeling Project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15gE974SdIPiy4z828GtWwjIhDAg6sjw2

# **Math Modeling Project**

## We find the steady-state wave speed for the IC profile:  1 - (1/2)(1 + tanh(x/L)).
"""

import numpy as np
import matplotlib.pyplot as plt

"""## Methods: 

### The plots are of a single wave as it moves through time given a certain IC. The wave is plotted in intervals of 1 unit of time, and each IC differs by the choice of L.

### We find the wave speed by comparing the x-values of when the wave=0.5 for various times. This is done by observing the index where the wave plot is closest to 0.5, then finding the difference of indexes, and scaling the index to the x-values. Note that since each wave plot is 1 second away, no time scaling needs to happen.

### L = 0.01
"""

# step size and time size
dx = 0.1
dt = 0.001
# make grid
x = np.arange(-2, 200, dx)
# need to define this before any plotting
plt.figure(figsize = (24, 8))
# compute initial condition
u = (1/2)*(1-np.tanh(x/0.01))
indexes = []

# plot wave at 100 different times
for i in range (100):
  plt.plot(x, u)

  # spot index of ~0.5 on wave
  for j in range (len(u)):
    threshold = 0.01
    if abs(u[j] - 0.5) < threshold:
      index = j
      threshold = abs(u[j] - 0.5)
  indexes = np.concatenate([indexes, [index]])

  # update wave
  # 1000 updates and dt=0.001 means each update loop increases by 1 time unit
  for k in range(1000):
    # compute vector of forward differences (first and second derivative w/ respect to x)
    forward_diff = np.diff(u)/dx
    forward_diff_2 = np.diff(forward_diff)/dx

    #compute u_change
    u_change_1 = u*(1-u)*dt
    u_change_2 = forward_diff_2*dt
    u += u_change_1
    u[1:-1] += u_change_2

# plot solution
plt.show()

# print indexes of ~0.5 value and difference in index
print(indexes)
print(np.diff(indexes))
print(np.diff(indexes)*0.1)

"""### Wave Speed ~ 2

### L = 0.1
"""

# step size and time size
dx = 0.1
dt = 0.001
# make grid
x = np.arange(-2, 200, dx)
# need to define this before any plotting
plt.figure(figsize = (24, 8))
# compute initial condition
u = (1/2)*(1-np.tanh(x/0.1))
indexes = []

# plot wave at 100 different times
for i in range (100):
  plt.plot(x, u)

  # spot index of ~0.5 on wave
  for j in range (len(u)):
    threshold = 0.01
    if abs(u[j] - 0.5) < threshold:
      index = j
      threshold = abs(u[j] - 0.5)
  indexes = np.concatenate([indexes, [index]])

  # update wave
  # 1000 updates and dt=0.001 means each update loop increases by 1 time unit
  for k in range(1000):
    # compute vector of forward differences (first and second derivative w/ respect to x)
    forward_diff = np.diff(u)/dx
    forward_diff_2 = np.diff(forward_diff)/dx

    #compute u_change
    u_change_1 = u*(1-u)*dt
    u_change_2 = forward_diff_2*dt
    u += u_change_1
    u[1:-1] += u_change_2

# plot solution
plt.show()

# print changes in x
print(np.diff(indexes)*0.1)

"""### Wave Speed ~ 2

## L=1
"""

# step size and time size
dx = 0.1
dt = 0.001
# make grid
x = np.arange(-10, 200, dx)
# need to define this before any plotting
plt.figure(figsize = (24, 8))
# compute initial condition
u = (1/2)*(1-np.tanh(x))
indexes = []

# plot wave at 100 different times
for i in range (100):
  plt.plot(x, u)

  # spot index of ~0.5 on wave
  for j in range (len(u)):
    threshold = 0.01
    if abs(u[j] - 0.5) < threshold:
      index = j
      threshold = abs(u[j] - 0.5)
  indexes = np.concatenate([indexes, [index]])

  # update wave
  # 1000 updates and dt=0.001 means each update loop increases by 1 time unit
  for k in range(1000):
    # compute vector of forward differences (first and second derivative w/ respect to x)
    forward_diff = np.diff(u)/dx
    forward_diff_2 = np.diff(forward_diff)/dx

    #compute u_change
    u_change_1 = u*(1-u)*dt
    u_change_2 = forward_diff_2*dt
    u += u_change_1
    u[1:-1] += u_change_2

# plot solution
plt.show()

# print changes in x
print(np.diff(indexes)*0.1)

"""### Wave Speed ~ 2

## L = 5
"""

# step size and time size
dx = 0.1
dt = 0.001
# make grid
x = np.arange(-15, 360, dx)
# need to define this before any plotting
plt.figure(figsize = (24, 8))
# compute initial condition
u = (1/2)*(1-np.tanh(x/5))
indexes = []

# plot wave at 150 different times
for i in range (150):
  plt.plot(x, u)

  # spot index of ~0.5 on wave
  for j in range (len(u)):
    threshold = 0.01
    if abs(u[j] - 0.5) < threshold:
      index = j
      threshold = abs(u[j] - 0.5)
  indexes = np.concatenate([indexes, [index]])

  # update wave
  # 1000 updates and dt=0.001 means each update loop increases by 1 time unit
  for k in range(1000):
    # compute vector of forward differences (first and second derivative w/ respect to x)
    forward_diff = np.diff(u)/dx
    forward_diff_2 = np.diff(forward_diff)/dx

    #compute u_change
    u_change_1 = u*(1-u)*dt
    u_change_2 = forward_diff_2*dt
    u += u_change_1
    u[1:-1] += u_change_2

# plot solution
plt.show()

# print changes in x
print(np.diff(indexes)*0.1)

"""### Wave Speed ~ 2

## L = 10
"""

# step size and time size
dx = 0.1
dt = 0.001
# make grid
x = np.arange(-25, 660, dx)
# need to define this before any plotting
plt.figure(figsize = (24, 8))
# compute initial condition
u = (1/2)*(1-np.tanh(x/10))
indexes = []

# plot wave at 250 different times
for i in range (250):
  plt.plot(x, u)

  # spot index of ~0.5 on wave
  for j in range (len(u)):
    threshold = 0.01
    if abs(u[j] - 0.5) < threshold:
      index = j
      threshold = abs(u[j] - 0.5)
  indexes = np.concatenate([indexes, [index]])

  # update wave
  # 1000 updates and dt=0.001 means each update loop increases by 1 time unit
  for k in range(1000):
    # compute vector of forward differences (first and second derivative w/ respect to x)
    forward_diff = np.diff(u)/dx
    forward_diff_2 = np.diff(forward_diff)/dx

    #compute u_change
    u_change_1 = u*(1-u)*dt
    u_change_2 = forward_diff_2*dt
    u += u_change_1
    u[1:-1] += u_change_2

# plot solution
plt.show()

# print changes in x
print(np.diff(indexes)*0.1)

"""### Wave speed ~ 2

## L = 20
"""

# step size and time size
dx = 0.1
dt = 0.001
# make grid
x = np.arange(-50, 850, dx)
# need to define this before any plotting
plt.figure(figsize = (24, 8))
# compute initial condition
u = (1/2)*(1-np.tanh(x/20))
indexes = []

# plot wave at 250 different times
for i in range (250):
  plt.plot(x, u)

  # spot index of ~0.5 on wave
  for j in range (len(u)):
    threshold = 0.01
    if abs(u[j] - 0.5) < threshold:
      index = j
      threshold = abs(u[j] - 0.5)
  indexes = np.concatenate([indexes, [index]])

  # update wave
  # 1000 updates and dt=0.001 means each update loop increases by 1 time unit
  for k in range(1000):
    # compute vector of forward differences (first and second derivative w/ respect to x)
    forward_diff = np.diff(u)/dx
    forward_diff_2 = np.diff(forward_diff)/dx

    #compute u_change
    u_change_1 = u*(1-u)*dt
    u_change_2 = forward_diff_2*dt
    u += u_change_1
    u[1:-1] += u_change_2

# plot solution
plt.show()

# print changes in x
print(np.diff(indexes)*0.1)

"""### Wave speed ~ 2

## L = 30
"""

# step size and time size
dx = 0.1
dt = 0.001
# make grid
x = np.arange(-90, 1050, dx)
# need to define this before any plotting
plt.figure(figsize = (24, 8))
# compute initial condition
u = (1/2)*(1-np.tanh(x/30))
indexes = []

# plot wave at 250 different times
for i in range (250):
  plt.plot(x, u)

  # spot index of ~0.5 on wave
  for j in range (len(u)):
    threshold = 0.01
    if abs(u[j] - 0.5) < threshold:
      index = j
      threshold = abs(u[j] - 0.5)
  indexes = np.concatenate([indexes, [index]])

  # update wave
  # 1000 updates and dt=0.001 means each update loop increases by 1 time unit
  for k in range(1000):
    # compute vector of forward differences (first and second derivative w/ respect to x)
    forward_diff = np.diff(u)/dx
    forward_diff_2 = np.diff(forward_diff)/dx

    #compute u_change
    u_change_1 = u*(1-u)*dt
    u_change_2 = forward_diff_2*dt
    u += u_change_1
    u[1:-1] += u_change_2

# plot solution
plt.show()

# print changes in x
print(np.diff(indexes)*0.1)

"""### Wave Speed ~ 2

## L = 50
"""

# step size and time size
dx = 0.1
dt = 0.001
# make grid
x = np.arange(-180, 1520, dx)
# need to define this before any plotting
plt.figure(figsize = (24, 8))
# compute initial condition
u = (1/2)*(1-np.tanh(x/50))
indexes = []

# plot wave at 250 different times
for i in range (250):
  plt.plot(x, u)

  # spot index of ~0.5 on wave
  for j in range (len(u)):
    threshold = 0.01
    if abs(u[j] - 0.5) < threshold:
      index = j
      threshold = abs(u[j] - 0.5)
  indexes = np.concatenate([indexes, [index]])

  # update wave
  # 1000 updates and dt=0.001 means each update loop increases by 1 time unit
  for k in range(1000):
    # compute vector of forward differences (first and second derivative w/ respect to x)
    forward_diff = np.diff(u)/dx
    forward_diff_2 = np.diff(forward_diff)/dx

    #compute u_change
    u_change_1 = u*(1-u)*dt
    u_change_2 = forward_diff_2*dt
    u += u_change_1
    u[1:-1] += u_change_2

# plot solution
plt.show()

# print changes in x
print(np.diff(indexes)*0.1)

"""### Wave Speed ~ 2

## L = 100
"""

# step size and time size
dx = 0.1
dt = 0.001
# make grid
x = np.arange(-250, 2500, dx)
# need to define this before any plotting
plt.figure(figsize = (24, 8))
# compute initial condition
u = (1/2)*(1-np.tanh(x/100))
indexes = []

# plot wave at 250 different times
for i in range (250):
  plt.plot(x, u)

  # spot index of ~0.5 on wave
  for j in range (len(u)):
    threshold = 0.01
    if abs(u[j] - 0.5) < threshold:
      index = j
      threshold = abs(u[j] - 0.5)
  indexes = np.concatenate([indexes, [index]])

  # update wave
  # 1000 updates and dt=0.001 means each update loop increases by 1 time unit
  for k in range(1000):
    # compute vector of forward differences (first and second derivative w/ respect to x)
    forward_diff = np.diff(u)/dx
    forward_diff_2 = np.diff(forward_diff)/dx

    #compute u_change
    u_change_1 = u*(1-u)*dt
    u_change_2 = forward_diff_2*dt
    u += u_change_1
    u[1:-1] += u_change_2

# plot solution
plt.show()

# print changes in x
print(np.diff(indexes)*0.1)

"""### Wave speed ~ 2

## Analysis: 

### As L gets bigger, the initial wave speed is faster and the initial profile is flatter. The effect of L's size diminishes as L gets smaller, but increases as L gets bigger... Meaning: the initial wave profile/speed is roughly the same for L = 0.01 -> 0.1 -> 1, but drastically different for L = 1 -> 10 -> 100.

### Despite the initial speed, the steady state wave speed ends up converging to 2, no matter how large L is (or how small L is).

### Some possible limitations are the fact that we only tried L up to 100, but higher L would run into serious computational problems.

### We conclude that the steady state wave speed is 2 for any wave that has the IC profile given under Fisher's equation.
"""